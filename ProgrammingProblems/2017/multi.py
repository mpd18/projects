'''
Author: Shahidul Islam (Sumon)
2 key features are included is the problem (Multiples - 2017 UCF Local Contest):
- Inclusion/Exclusion.
- Linear sorting of generated products (preferably using progressive merging of base product list).
1st one in mandatory. 2nd one asks for as good as efficient sorting possible, given the pattern of data generation.
'''

import bisect
from heapq import merge

# Generate all primes in the range [3, 130]
primes = []

for x in range(3, 130):
    prime = 1
    for y in range(2, x):
        if x % y == 0:
            prime = 0
    if prime == 1:
        primes.append(x)


# Now we make a list of all products of subsets of odd primes within max b range, as well as a factor count parity (0 for even and 1 for odd).
# We start the set with the first odd prime 3.

'''
- baseProducts* will hold partially ordered list, where sublist generated by a new prime inclusion is ordered 
- mergedProducts* will store the sorted product
- startIndices* will hold the current size of the list of products and wil be updated after each prime is considered
- all these list has two categories of list to store product with odd and even number of prime factors
'''
baseProductsOddPrimeFactor = [3, 5]
mergedProductsOddPrimeFactor = [3, 5]
startIndicesOddPrimeFactor = [0, 1]

baseProductsEvenPrimeFactor = [15]
mergedProductsEvenPrimeFactor = [15]
startIndicesEvenPrimeFactor = [0, 0]

'''
Go through each prime, and add that prime into each already existing set
by appending the new product and size to the lists.
'''

maxValue = 1000000000000000

def extendList(mergedProducts, baseProducts, limitValue, startIndices, tempList, p):
    limitIndex = bisect.bisect_right(mergedProducts, limitValue)
    startIndices.append(len(baseProducts))
    #multiply the current prime with the existing prime products
    tempList.extend(x * p for x in mergedProducts[0:limitIndex])
    # merge the ordered sublists
    baseProducts.extend(tempList)

for i in range(2, len(primes)):
    tempListOdd = [primes[i]]
    tempListEven = []

    limit = int(maxValue / primes[i])

    extendList(mergedProductsEvenPrimeFactor, baseProductsOddPrimeFactor, limit, startIndicesOddPrimeFactor, tempListOdd, primes[i])
    extendList(mergedProductsOddPrimeFactor, baseProductsEvenPrimeFactor, limit, startIndicesEvenPrimeFactor, tempListEven, primes[i])
    # merge the ordered sublists
    if(i < len(primes) - 1):
        mergedProductsOddPrimeFactor = list(merge(mergedProductsOddPrimeFactor, tempListOdd))
        mergedProductsEvenPrimeFactor = list(merge(mergedProductsEvenPrimeFactor, tempListEven))

startIndicesOddPrimeFactor.append(len(baseProductsOddPrimeFactor))
startIndicesEvenPrimeFactor.append(len(baseProductsEvenPrimeFactor))

# Now, process the test cases.
def process_input():
    T = int(input())
    for t in range(0, T):
        # Read in the input
        a, b = map(int, input().split())

        # Count how many terms we will need to consider during inclusion-exclusion.
        # Ordered sublist in the list will help to break the nested loop early at each iteration
        res = 0

        for i in range(0, len(primes)):
            if(primes[i] > a):
                break;

            limitIndexOdd = startIndicesOddPrimeFactor[i] + bisect.bisect_right(baseProductsOddPrimeFactor[startIndicesOddPrimeFactor[i]: startIndicesOddPrimeFactor[i + 1]], b)
            limitIndexEven = startIndicesEvenPrimeFactor[i] + bisect.bisect_right(baseProductsEvenPrimeFactor[startIndicesEvenPrimeFactor[i]: startIndicesEvenPrimeFactor[i + 1]], b)

            divOddProduct = [int((int(b / x) + 1) / 2) for x in baseProductsOddPrimeFactor[startIndicesOddPrimeFactor[i]:limitIndexOdd]]
            divEvenProduct = [int((int(b / x) + 1) / 2) for x in baseProductsEvenPrimeFactor[startIndicesEvenPrimeFactor[i]:limitIndexEven]]

            res = res + sum(divOddProduct)
            res = res - sum(divEvenProduct)

        res = res + int(b / 2) #odd product (res) + even products
        print (res)

process_input()
